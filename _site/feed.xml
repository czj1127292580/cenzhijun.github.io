<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>岑志军的个人博客</title>
    <description>欢迎来到我的博客~</description>
    <link>http://www.cenzhijun.top//</link>
    <atom:link href="http://www.cenzhijun.top//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 28 Mar 2018 11:29:41 +0800</pubDate>
    <lastBuildDate>Wed, 28 Mar 2018 11:29:41 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>（3）OC中消息和消息转发-01</title>
        <description>&lt;p&gt;前一段时间有朋友问了下面的这个问题，我给出的回答是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-26-15220365281833.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其实上面回答的方法调用也都是基于以前对runtime的理解，和自己试验出来的结果，但是，回答完这个问题之后，抱着探究到底的精神（其实是这几天产品没提什么需求，有点儿闲），问了自己一个问题：你怎么知道是底层调用的是这几个方法？？。。。又是一番查资料，验证问题。。。下面正式开始分析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先新建一个Person类，代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Person.h
```
#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/p&gt;

&lt;p&gt;@interface Person : NSObject&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(void)eat;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@end
```&lt;/p&gt;

&lt;p&gt;Person.m&lt;/p&gt;

&lt;p&gt;```
#import “Person.h”&lt;/p&gt;

&lt;p&gt;@implementation Person&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(void)eat{
  NSLog(@”Person eat=======”);
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@end
```&lt;/p&gt;

&lt;p&gt;很简单的一个类&lt;/p&gt;

&lt;p&gt;在main函数里面调用&lt;code class=&quot;highlighter-rouge&quot;&gt;eat&lt;/code&gt;方法：&lt;/p&gt;

&lt;p&gt;```
Person *p = [[Person alloc] init];&lt;/p&gt;

&lt;p&gt;[p eat];
```&lt;/p&gt;

&lt;p&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;main.m&lt;/code&gt;代码转换成c++代码：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp
&lt;/code&gt;
在&lt;code class=&quot;highlighter-rouge&quot;&gt;main.cpp&lt;/code&gt;文件当中查看底层实现：&lt;/p&gt;

&lt;p&gt;```
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Person *p = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));

    ((void (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName(&quot;eat&quot;));

}
return 0; } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过这些代码我们发现，OC中方法调用本质上就是给对象发消息，上面给对象发消息的代码可以简写成：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
objc_msgSend(p, @selector(eat));
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面方法调用的意思就是：给&lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;对象发送名为&lt;code class=&quot;highlighter-rouge&quot;&gt;eat&lt;/code&gt;的消息，所以OC中给对象发消息本质上都是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSend&lt;/code&gt;方法，接着看下苹果官方文档对这个方法的定义（我是用的Dash查看的）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-26-15220439314182.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt; ：指向接收消息的类实例的指针。简单来说就是消息的接收者。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;op&lt;/code&gt;：处理消息的方法选择器，也就是我们常见的&lt;code class=&quot;highlighter-rouge&quot;&gt;@selector()&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;：包含方法参数的可变参数列表，&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-26-15220443215386.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;翻译如下：&lt;/p&gt;

&lt;p&gt;当遇到方法调用时，编译器生成对其中一个函数的调用。当向superclass发消息的时候调用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSendSuper&lt;/code&gt;，向其他对象发消息的时候调用&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSend&lt;/code&gt;，方法返回值是一个结构体的时候调用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSendSuper_stret&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSend_stret&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;接下来我们再看下&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSend&lt;/code&gt;的底层实现，&lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot;&gt;objc 源码&lt;/a&gt;，发现底层是用汇编代码实现的（表示很蛋疼）：&lt;/p&gt;

&lt;p&gt;```
ENTRY _objc_msgSend
	UNWIND _objc_msgSend, NoFrame
	MESSENGER_START&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NilTest	NORMAL

GetIsaFast NORMAL		// r10 = self-&amp;gt;isa  
CacheLookup NORMAL, CALL	// calls IMP on success

NilTestReturnZero NORMAL

GetIsaSupport NORMAL
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;// cache miss: go search the method lists
LCacheMiss:
	// isa still in r10
	MESSENGER_END_SLOW
	jmp	__objc_msgSend_uncached&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;END_ENTRY _objc_msgSend ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于本人汇编就懂几个简单的指令，所以就做简单分析：&lt;/p&gt;

&lt;p&gt;首先，&lt;code class=&quot;highlighter-rouge&quot;&gt;GetIsaFast&lt;/code&gt;获取对象的isa指针，接着通过&lt;code class=&quot;highlighter-rouge&quot;&gt;CacheLookup&lt;/code&gt;从缓存查找方法的实现，会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;cache_getImp(Class cls, SEL sel)&lt;/code&gt;，如果缓存中没有查到也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;cache miss&lt;/code&gt;，会跳到&lt;code class=&quot;highlighter-rouge&quot;&gt;__objc_msgSend_uncached&lt;/code&gt;方法：&lt;/p&gt;

&lt;p&gt;```
STATIC_ENTRY __objc_msgSend_uncached
	UNWIND __objc_msgSend_uncached, FrameWithNoSaves&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// THIS IS NOT A CALLABLE C FUNCTION
// Out-of-band r10 is the searched class

// r10 is already the class to search
MethodTableLookup NORMAL	// r11 = IMP
jmp	*%r11			// goto *imp

END_ENTRY __objc_msgSend_uncached ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这个方法里面又会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;MethodTableLookup&lt;/code&gt;查找方法列表：&lt;/p&gt;

&lt;p&gt;```
.macro MethodTableLookup&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;push	%rbp
mov	%rsp, %rbp

sub	$$0x80+8, %rsp		// +8 for alignment

movdqa	%xmm0, -0x80(%rbp)
push	%rax			// might be xmm parameter count
movdqa	%xmm1, -0x70(%rbp)
push	%a1
movdqa	%xmm2, -0x60(%rbp)
push	%a2
movdqa	%xmm3, -0x50(%rbp)
push	%a3
movdqa	%xmm4, -0x40(%rbp)
push	%a4
movdqa	%xmm5, -0x30(%rbp)
push	%a5
movdqa	%xmm6, -0x20(%rbp)
push	%a6
movdqa	%xmm7, -0x10(%rbp)

// _class_lookupMethodAndLoadCache3(receiver, selector, class)    ...    ...    省略 ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;MethodTableLookup&lt;/code&gt;里面又调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;_class_lookupMethodAndLoadCache3&lt;/code&gt;方法：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
/***********************************************************************
* _class_lookupMethodAndLoadCache.
* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().
* This lookup avoids optimistic cache scan because the dispatcher 
* already tried that.
**********************************************************************/
IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)
{
    return lookUpImpOrForward(cls, sel, obj, 
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接下来看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;lookUpImpOrForward&lt;/code&gt;的实现&lt;/p&gt;

&lt;p&gt;```
IMP lookUpImpOrForward(Class cls, SEL sel, id inst, 
                       bool initialize, bool cache, bool resolver)
{
    IMP imp = nil;
    bool triedResolver = NO;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;runtimeLock.assertUnlocked();

// Optimistic cache lookup
if (cache) {
    imp = cache_getImp(cls, sel);
    if (imp) return imp;
}

// runtimeLock is held during isRealized and isInitialized checking
// to prevent races against concurrent realization.

// runtimeLock is held during method search to make
// method-lookup + cache-fill atomic with respect to method addition.
// Otherwise, a category could be added but ignored indefinitely because
// the cache was re-filled with the old value after the cache flush on
// behalf of the category.

runtimeLock.read();

if (!cls-&amp;gt;isRealized()) {
    // Drop the read-lock and acquire the write-lock.
    // realizeClass() checks isRealized() again to prevent
    // a race while the lock is down.
    runtimeLock.unlockRead();
    runtimeLock.write();

    realizeClass(cls);

    runtimeLock.unlockWrite();
    runtimeLock.read();
}

if (initialize  &amp;amp;&amp;amp;  !cls-&amp;gt;isInitialized()) {
    runtimeLock.unlockRead();
    _class_initialize (_class_getNonMetaClass(cls, inst));
    runtimeLock.read();
    // If sel == initialize, _class_initialize will send +initialize and 
    // then the messenger will send +initialize again after this 
    // procedure finishes. Of course, if this is not being called 
    // from the messenger then it won&#39;t happen. 2778172
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;retry:  &lt;br /&gt;
    runtimeLock.assertReading();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Try this class&#39;s cache.

imp = cache_getImp(cls, sel);
if (imp) goto done;

// Try this class&#39;s method lists.
{
    Method meth = getMethodNoSuper_nolock(cls, sel);
    if (meth) {
        log_and_fill_cache(cls, meth-&amp;gt;imp, sel, inst, cls);
        imp = meth-&amp;gt;imp;
        goto done;
    }
}

// Try superclass caches and method lists.
{
    unsigned attempts = unreasonableClassCount();
    for (Class curClass = cls-&amp;gt;superclass;
         curClass != nil;
         curClass = curClass-&amp;gt;superclass)
    {
        // Halt if there is a cycle in the superclass chain.
        if (--attempts == 0) {
            _objc_fatal(&quot;Memory corruption in class list.&quot;);
        }
        
        // Superclass cache.
        imp = cache_getImp(curClass, sel);
        if (imp) {
            if (imp != (IMP)_objc_msgForward_impcache) {
                // Found the method in a superclass. Cache it in this class.
                log_and_fill_cache(cls, imp, sel, inst, curClass);
                goto done;
            }
            else {
                // Found a forward:: entry in a superclass.
                // Stop searching, but don&#39;t cache yet; call method 
                // resolver for this class first.
                break;
            }
        }
        
        // Superclass method list.
        Method meth = getMethodNoSuper_nolock(curClass, sel);
        if (meth) {
            log_and_fill_cache(cls, meth-&amp;gt;imp, sel, inst, curClass);
            imp = meth-&amp;gt;imp;
            goto done;
        }
    }
}

// No implementation found. Try method resolver once.

if (resolver  &amp;amp;&amp;amp;  !triedResolver) {
    runtimeLock.unlockRead();
    _class_resolveMethod(cls, sel, inst);
    runtimeLock.read();
    // Don&#39;t cache the result; we don&#39;t hold the lock so it may have 
    // changed already. Re-do the search from scratch instead.
    triedResolver = YES;
    goto retry;
}

// No implementation found, and method resolver didn&#39;t help. 
// Use forwarding.

imp = (IMP)_objc_msgForward_impcache;
cache_fill(cls, sel, imp, inst);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;done:
    runtimeLock.unlockRead();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return imp; } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们重点看&lt;code class=&quot;highlighter-rouge&quot;&gt;// No implementation found. Try method resolver once.&lt;/code&gt;下面的代码，如果依然没有找到方法的实现，会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;_class_resolveMethod&lt;/code&gt;方法：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
void _class_resolveMethod(Class cls, SEL sel, id inst)
{
    if (! cls-&amp;gt;isMetaClass()) {
        // try [cls resolveInstanceMethod:sel]
        _class_resolveInstanceMethod(cls, sel, inst);
    } 
    else {
        // try [nonMetaClass resolveClassMethod:sel]
        // and [cls resolveInstanceMethod:sel]
        _class_resolveClassMethod(cls, sel, inst);
        if (!lookUpImpOrNil(cls, sel, inst, 
                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) 
        {
            _class_resolveInstanceMethod(cls, sel, inst);
        }
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在这个方法里面，我们可以清楚地看到，首先会判断该对象是否是元类对象，如果不是，会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;_class_resolveInstanceMethod&lt;/code&gt;方法，否则会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;_class_resolveClassMethod&lt;/code&gt;方法。如果还没有找到对应的IMP方法实现：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
// No implementation found, and method resolver didn&#39;t help. 
// Use forwarding.
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接下来就会用到消息转发，调用这个方法&lt;code class=&quot;highlighter-rouge&quot;&gt;_objc_msgForward_impcache&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```
/&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;**
*
* id _objc_msgForward(id self, SEL _cmd,…);
*
* _objc_msgForward and _objc_msgForward_stret are the externally-callable
*   functions returned by things like method_getImplementation().
* _objc_msgForward_impcache is the function pointer actually stored in
*   method caches.
*
&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;**/&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;STATIC_ENTRY __objc_msgForward_impcache
// Method cache version

// THIS IS NOT A CALLABLE C FUNCTION
// Out-of-band condition register is NE for stret, EQ otherwise.

MESSENGER_START
nop
MESSENGER_END_SLOW

jne	__objc_msgForward_stret
jmp	__objc_msgForward

END_ENTRY __objc_msgForward_impcache


ENTRY __objc_msgForward
// Non-stret version

movq	__objc_forward_handler(%rip), %r11
jmp	*%r11

END_ENTRY __objc_msgForward


ENTRY __objc_msgForward_stret
// Struct-return version

movq	__objc_forward_stret_handler(%rip), %r11
jmp	*%r11

END_ENTRY __objc_msgForward_stret
...    ...    省略 ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从description可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;__objc_msgForward_impcache&lt;/code&gt;实际上是一个存储在方法缓存当中的函数指针，当某种类型的对象处理消息的过程中，无论怎样都找不到对应的IMP实现时，会将它作为sel对应的imp记入缓存。所以，从严格意义上来讲&lt;code class=&quot;highlighter-rouge&quot;&gt;_class_resolveInstanceMethod&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;_class_resolveClassMethod&lt;/code&gt;并不是由&lt;code class=&quot;highlighter-rouge&quot;&gt;__objc_msgForward_impcache&lt;/code&gt;触发的，并不能算作消息转发的后续步骤，消息转发后，该对象如果再次遇到同名消息是，会直接从缓存中找到对应的IMP,即&lt;code class=&quot;highlighter-rouge&quot;&gt;_objc_msgForward_impcache&lt;/code&gt;，此时我们需要重写&lt;code class=&quot;highlighter-rouge&quot;&gt;- (id)forwardingTargetForSelector:(SEL)aSelector&lt;/code&gt;方法，重定向到别的类当中找到方法的实现。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
imp = (IMP)_objc_msgForward_impcache;
cache_fill(cls, sel, imp, inst);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;官方文档截图：
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-26-15220568983751.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要看下官方文档里面的Discussion：
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-26-15220569597686.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;官方文档写的非常清楚：当你只想将消息重定向到另一个类时，用这个方法非常有用，因为它比常规的转发快一个数量级,他转发的目标是捕获&lt;code class=&quot;highlighter-rouge&quot;&gt;NSInvocation&lt;/code&gt;。也有人将这种方式称为&lt;code class=&quot;highlighter-rouge&quot;&gt;Fast Forwarding&lt;/code&gt;，因为这一步不会创建&lt;code class=&quot;highlighter-rouge&quot;&gt;NSInvocation&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;今天先写这么多，还没完呢，上网查了好多资料，好多网上资料苹果的源代码都是老的，跟最新代码不太一样，也费了我很多时间，下一篇文章将会介绍如何通过&lt;code class=&quot;highlighter-rouge&quot;&gt;regular forwarding&lt;/code&gt;也有人叫&lt;code class=&quot;highlighter-rouge&quot;&gt;Normal Forwarding&lt;/code&gt;，动态添加方法实现。。。。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;References:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://lpd-ios.github.io/2017/12/19/ObjC-Message/&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://www.cenzhijun.top//2018/03/msgSend-01/</link>
        <guid isPermaLink="true">http://www.cenzhijun.top//2018/03/msgSend-01/</guid>
        
        <category>iOS底层</category>
        
        
      </item>
    
      <item>
        <title>（2）NSNumber及Tagged Pointer</title>
        <description>&lt;p&gt;根据上一篇文章的总结，我们很容易发现&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
@interface Student : NSObject
{
    @public
    int _age;
    int _no;
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一个Student对象在64位架构下占了16个字节，其中isa占8个字节，两个int变量分别占了4个字节，但是这种方式适合所有OC对象吗？？哈哈，并不是。。。&lt;/p&gt;

&lt;p&gt;今天早上有朋友问NSNumber为啥占用8个字节（64bit），请看NSNumber头文件，发现如下代码：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;charValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsignedCharValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shortValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsignedShortValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsignedIntValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;longValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsignedLongValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;longLongValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsignedLongLongValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;floatValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doubleValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boolValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;integerValue&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;API_AVAILABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;macos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ios&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;watchos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tvos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSUInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsignedIntegerValue&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;API_AVAILABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;macos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ios&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;watchos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tvos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;NSNumber对象里面有很多成员变量，为啥只占8个字节呢？？我们先做几个试验：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
NSNumber *number1 = [NSNumber numberWithInt:9];
NSNumber *number2 = [NSNumber numberWithInt:9];
NSNumber *number3 = [NSNumber numberWithInt:5];
NSNumber *number4 = [NSNumber numberWithInt:6];
NSLog(@&quot;\n%p\n%p\n%p\n%p&quot;, number1, number2,number3, number4);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面是打印结果：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
0xb000000000000093
0xb000000000000093
0xb000000000000052
0xb000000000000062
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们发现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;number1和number2的对象地址竟然是一样的&lt;/li&gt;
  &lt;li&gt;这几个地址除了&lt;code class=&quot;highlighter-rouge&quot;&gt;0xb&lt;/code&gt;和后面的&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;，其它的数刚好对应其NSNumber的值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以苹果确实是将值直接存在了指针本身当中了&lt;/p&gt;

&lt;p&gt;Google上发现一张NSNumber的内存图，很形象：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-22-NSNumber.png&quot; alt=&quot;NSNumbe&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这就很有意思了，我尝试着打印下他们的ISA指针，发现报如下错误：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-22-15217046164134.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是为什么呢，通过查找一些资料发现，&lt;a href=&quot;https://blog.devtang.com/2014/03/21/weak_object_lifecycle_and_tagged_pointer/&quot;&gt;唐巧在很早前的一篇文章&lt;/a&gt;中提到&lt;code class=&quot;highlighter-rouge&quot;&gt;Tagged Pointer&lt;/code&gt;：一下是摘录：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在WWDC2013的《Session 404 Advanced in Objective-C》视频中，苹果介绍了Tagged Pointer。Tagged Pointer的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在64位系统中，如果我们真正使用一个指针来存储NSNumber实例，那么我们首先需要一个8字节的指针，另外需要一块内存存储NSNumber实例，这通常又是8字节。这样的内存开销是比较大的。苹果对于NSNumber和NSDate对象，改成了用Tagged Pointer来存储，简单来说，Tagged Pointer是一个假的指针，它的值不再是另一个地址，而就是对应变量的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tagged Pointer主要有以下3个特点：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate
Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已！所以，它的内存并不存储在堆中，也不需要malloc和free。
在内存读取上有着3倍的效率（以前是寻址-&amp;gt;发消息-&amp;gt;获取值，现在直接获取值），创建时比以前快106倍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相关英文文档截图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-22-15217049155699.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看了上面的文章，终于恍然大悟了，大神不愧是大神，这篇文章是14年初写的。。。&lt;/p&gt;

&lt;p&gt;所以我们得出如下结论：
* &lt;code class=&quot;highlighter-rouge&quot;&gt;Tagged Pointer&lt;/code&gt;并不是真正的对象,而是一个伪对象&lt;/p&gt;

&lt;p&gt;因为&lt;code class=&quot;highlighter-rouge&quot;&gt;Tagged Pointer&lt;/code&gt;不是一个真正的对象，所以当你访问它的ISA的时候自然就会报上面的错误了。&lt;/p&gt;

&lt;p&gt;如果一个数超过了&lt;code class=&quot;highlighter-rouge&quot;&gt;Tagged Pointer&lt;/code&gt;所能表示的范围，又会怎么处理呢？同样做个试验：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
NSNumber *bigNumber = @(0xEFFFFFFFFFFFFFFF);
NSLog(@&quot;%p&quot;, bigNumber);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打印结果：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
0x6000002310c0
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们发现&lt;code class=&quot;highlighter-rouge&quot;&gt;bigNumber&lt;/code&gt;更像一个普通的地址，跟他本身的值并没有什么关系，我们可以打印一下他的ISA，发现是可以打印的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-22-15217063008204.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以可以得出如下结论：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当8字节可以承载用于表示的数值时，系统就会以&lt;code class=&quot;highlighter-rouge&quot;&gt;Tagged Pointer&lt;/code&gt;的方式生成指针，如果8字节承载不了时，则又用以前的方式来生成普通的指针。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;References:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://blog.devtang.com/2014/03/21/weak_object_lifecycle_and_tagged_pointer/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 22 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://www.cenzhijun.top//2018/03/NSNumber%E5%8F%8ATagged-Pointer/</link>
        <guid isPermaLink="true">http://www.cenzhijun.top//2018/03/NSNumber%E5%8F%8ATagged-Pointer/</guid>
        
        <category>iOS底层</category>
        
        
      </item>
    
      <item>
        <title>（1）Objective-C的本质</title>
        <description>&lt;p&gt;众说周知，我们平时编写的OC代码，底层都是C/C++实现的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-13-15209130736084.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以通过一个终端指令，将我们的OC代码转换成C/C++代码&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc 文件名 -o 输出的CPP文件
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;occc&quot;&gt;思考一：OC的对象、类都是基于C/C++什么数据结构实现的？？&lt;/h2&gt;

&lt;p&gt;首先看下面代码：&lt;/p&gt;

&lt;p&gt;```
#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &amp;lt;objc/runtime.h&amp;gt;&lt;/p&gt;

&lt;p&gt;@interface Student : NSObject
{
    @public
    int _age;
    int _no;
}
@end&lt;/p&gt;

&lt;p&gt;@implementation Student
@end&lt;/p&gt;

&lt;p&gt;int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Student *stu = [[Student alloc] init];&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    stu-&amp;gt;_age = 4;
    stu-&amp;gt;_no = 5;
    
    NSLog(@&quot;%@&quot;, stu);
    
    NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class]));
    NSLog(@&quot;%zd&quot;, class_getInstanceSize([Student class]));
}
return 0; } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过终端命令生成.cpp文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们发现Student和NSObject的底层实现代码如下：&lt;/p&gt;

&lt;p&gt;```
struct Student_IMPL {
	struct NSObject_IMPL NSObject_IVARS;
	int _age;
	int _no;
};&lt;/p&gt;

&lt;p&gt;struct NSObject_IMPL {
	Class isa;
};
```&lt;/p&gt;

&lt;p&gt;所以，OC的对象、类都是基于C/C++当中结构体实现的。&lt;/p&gt;

&lt;p&gt;那么，一个NSObject对象占用多少内存呢？&lt;/p&gt;

&lt;p&gt;通过以上代码，我们发现一个NSObject对象占用的内存大小是一个指针变量所占用的大小（64bit，8个字节。32bit，4个字节）&lt;/p&gt;

&lt;p&gt;同样可以通过代码检验&lt;/p&gt;

&lt;p&gt;方法一：通过runtime方法检验&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class]));
&lt;/code&gt;
终端打印结果：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
2018-03-13 12:02:26.584356+0800 TestDemo[33726:1665977] 8
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;方法二：实时查看内存数据&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
Debug -&amp;gt; Debug Workfllow -&amp;gt; View Memory （Shift + Command + M）
&lt;/code&gt;
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-13-15209139194113.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-13-15209142507883.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入内存地址：
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-13-15209142877899.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同样发现一个Student占16个字节，其中指针占了8个字节&lt;/p&gt;

&lt;p&gt;方法三：可以通过lldb命令查看&lt;/p&gt;

&lt;p&gt;常用lldb命令
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-13-15209143991235.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查看结果如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
(lldb) x/4xw 0x102c0a590
0x102c0a590: 0x000011c9 0x001d8001 0x00000004 0x00000005
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还可以通过lldb命令修改对象的值：
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-13-15209148405061.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;classinstancemeta-class&quot;&gt;类、实例对象、元类（class、instance、meta-class）&lt;/h2&gt;

&lt;h3 id=&quot;class&quot;&gt;类(class)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt;：类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起(百科上的回答)。简单的说就是数据及行为的封装&lt;/p&gt;

&lt;p&gt;通过查阅 Apple 官方开源的 &lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot;&gt;objc 源码&lt;/a&gt;，可以看到类的数据结构如下：&lt;/p&gt;

&lt;p&gt;```
struct objc_class : objc_object {
    // Class ISA;
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class_rw_t *data() { 
    return bits.data();
}
void setData(class_rw_t *newData) {
    bits.setData(newData);
}

...
...
...（省略） } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```
struct class_rw_t {
    // Be warned that Symbolication knows the layout of this structure.
    uint32_t flags;
    uint32_t version;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const class_ro_t *ro;

method_array_t methods; // 方法信息
property_array_t properties;    // 属相信息
protocol_array_t protocols;     // 协议信息

Class firstSubclass;
Class nextSiblingClass;

...
...
...（省略） ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```
struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;  // 对象占用的内存大小
#ifdef &lt;strong&gt;LP64&lt;/strong&gt;
    uint32_t reserved;
#endif&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const uint8_t * ivarLayout;

const char * name;  // 类名
method_list_t * baseMethodList;
protocol_list_t * baseProtocols;
const ivar_list_t * ivars;  // 成员变量列表

const uint8_t * weakIvarLayout;
property_list_t *baseProperties;

method_list_t *baseMethods() const {
    return baseMethodList;
} }; ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过以上代码我们发现Class对象在内存中存储的信息主要包括：
* isa指针
* superclass指针
* 属性信息
* 协议信息&lt;/p&gt;

&lt;p&gt;同时我们发现objc_class 继承自 objc_object，哈哈，其实类也是一个对象。。。&lt;/p&gt;

&lt;p&gt;```
NSObject *obj1 = [[NSObject alloc] init];
        NSObject *obj2 = [[NSObject alloc] init];&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Class objClass1 = [obj1 class];
    Class objClass2 = [obj2 class];
    Class objClass3 = [NSObject class];
    Class objClass4 = object_getClass(obj1);
    Class objClass5 = object_getClass(obj2);
    
    NSLog(@&quot;\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n&quot;, obj1, obj2, objClass1, objClass2, objClass3, objClass4, objClass5); ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-19-15214463000418.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过以上试验，我们发现，NSObject生成两个实例对象obj1、obj2，这两个实例对象分布在不同的内存地址，但是他们的Class指针是一样的，所以我们得出以下结论：
* objClass1 ~ objClass5都是NSObject的class对象（类对象）
* 它们是同一个对象。每个类在内存中有且只有一个class对象&lt;/p&gt;

&lt;h3 id=&quot;instance&quot;&gt;实例对象(instance)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;对象&lt;/strong&gt;：对象是具有类类型的变量（百科）。其实对象就是一个类的具体实例。在 Objective-C 中，含有一个 isa 指针并且可以正确指向某个类的数据结构，都可以视作为一个对象，其中 isa 指针指向当前对象所属的类，通过苹果开源的官方文档，同样可以发现它的数据结构，如下代码：&lt;/p&gt;

&lt;p&gt;```
struct objc_object {
private:
    isa_t isa;&lt;/p&gt;

&lt;p&gt;public:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ISA() assumes this is NOT a tagged pointer object
Class ISA();

// getIsa() allows this to be a tagged pointer object
Class getIsa();

// initIsa() should be used to init the isa of new objects only.
// If this object already has an isa, use changeIsa() for correctness.
// initInstanceIsa(): objects with no custom RR/AWZ
// initClassIsa(): class objects
// initProtocolIsa(): protocol objects
// initIsa(): other objects
void initIsa(Class cls /*nonpointer=false*/);
void initClassIsa(Class cls /*nonpointer=maybe*/);
void initProtocolIsa(Class cls /*nonpointer=maybe*/);
void initInstanceIsa(Class cls, bool hasCxxDtor);

...
...
...（省略） } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实上面代码中obj1、obj2就是NSObject生成的两个实例对象，不同的对象分别占据两块不同的内存。&lt;/p&gt;

&lt;p&gt;通过查看对象的底层代码，同样可以发现，对象在内存中的存储信息包含：
* isa指针
* 其它成员变量的值等&lt;/p&gt;

&lt;p&gt;就比如多个对象存在相同的属性，但是属性的值却存在不同的对象当中。&lt;/p&gt;

&lt;h3 id=&quot;meta-class&quot;&gt;元类（meta-class）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;元类&lt;/strong&gt;：元类其实就是描述类对象的类。简单的说就是类描述的是对象，而元类描述的是类。所以元类也定义了类的行为（类方法），其实元类的数据结构和类基本相同，只不过元类定义类的行为是类方法（+），而对象是对象方法（-）。原理都是遍历方法列表或者缓存列表&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
Class objMetaClass1 = objc_getMetaClass(&quot;NSObject&quot;);
Class objMetaClass2 = object_getClass([NSObject class]);
&lt;/code&gt;
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-19-15214483111601.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;objMetaClass1、objMetaClass2就是NSObject的meta-class对象（元类对象）&lt;/p&gt;

&lt;p&gt;每个类在内存中有且只有一个meta-class对象&lt;/p&gt;

&lt;p&gt;meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括：
* isa指针
* superclass指针
* 类的类方法信息（class method）等&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;查看class是否为meta-class&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
BOOL result = class_isMetaClass([NSObject class]);
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;方法的调用流程&lt;/h2&gt;

&lt;p&gt;通过以上信息我们就了解到了类、对象、元类之间的关系，那么类方法和对象方法的调用过程是怎样的呢？？如下图所示：
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-19-15214487235189.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;instance的isa指向class：
当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用&lt;/p&gt;

&lt;p&gt;class的isa指向meta-class：
当调用类方法是，通过class的isa找到meta-class,最后找到类方法的实现进行调用&lt;/p&gt;

&lt;h2 id=&quot;superclass&quot;&gt;superclass的作用&lt;/h2&gt;

&lt;p&gt;当一个对象调用父类方法时，其实就是通过isa找到class，然后通过superclass找到父类的class，最后找到对象方法的实现进行调用（类方法调用也是这个原理，通过isa找到meta-class,然后通过superclass找到父类的meta-class，最后找到类对象的实现进行调用）&lt;/p&gt;

&lt;h2 id=&quot;isasuperclass&quot;&gt;isa和superclass的调用流程&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sealiesoftware.com/blog/class%20diagram.pdf&quot;&gt;Greg Parker的一份精彩图谱&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-03-19-15214498988799.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过上图可以总结如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;instance的isa指向class&lt;/li&gt;
  &lt;li&gt;class的isa指向meta-class&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;meta-class的isa指向基类的meta-class&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;class的superclass指向父类的class&lt;/li&gt;
  &lt;li&gt;如果没有父类，superclass指针为nil&lt;/li&gt;
  &lt;li&gt;meta-class的superclass指向父类的meta-class&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;基类的meta-class的superclass指向基类的class&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;instance调用对象方法的轨迹
    &lt;ul&gt;
      &lt;li&gt;isa找到class，方法不存在，就通过superclass找父类&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;class调用类方法的轨迹
    &lt;ul&gt;
      &lt;li&gt;isa找meta-class，方法不存在，就通过superclass找父类&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 13 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://www.cenzhijun.top//2018/03/Objective-C%E7%9A%84%E6%9C%AC%E8%B4%A8/</link>
        <guid isPermaLink="true">http://www.cenzhijun.top//2018/03/Objective-C%E7%9A%84%E6%9C%AC%E8%B4%A8/</guid>
        
        <category>iOS底层</category>
        
        
      </item>
    
      <item>
        <title>（7）theos安装</title>
        <description>&lt;h2 id=&quot;ldid&quot;&gt;安装签名工具ldid&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;先确保安装了&lt;a href=&quot;https://brew.sh/&quot;&gt;brew&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;利用&lt;code class=&quot;highlighter-rouge&quot;&gt;brew&lt;/code&gt;安装&lt;code class=&quot;highlighter-rouge&quot;&gt;ldid&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ brew install ldid
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;修改环境变量&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;编辑用户的配置文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ vim ~/.bash_profile
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;.bash_profile&lt;/code&gt;文件后面加入以下2行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
export THEOS=~/theos
export PATH=$THEOS/bin:$PATH
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;让&lt;code class=&quot;highlighter-rouge&quot;&gt;.bash_profile&lt;/code&gt;配置的环境变量立即生效（或者重新打开终端）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ source ~/.bash_profile
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;theos&quot;&gt;下载theos&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;建议在&lt;code class=&quot;highlighter-rouge&quot;&gt;$THEOS&lt;/code&gt;目录下载代码（也就是刚才配置的&lt;code class=&quot;highlighter-rouge&quot;&gt;~/theos&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ git clone --recursive https://github.com/theos/theos.git $THEOS
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;tweak&quot;&gt;新建tweak项目&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;cd到一个存放项目代码的文件夹（比如桌面）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ cd ~/Desktop
$ nic.pl
&lt;/code&gt;
* 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;[11.] iphone/tweak&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15171339273450.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;填写项目信息
    &lt;ul&gt;
      &lt;li&gt;Project Name (项目名称)&lt;/li&gt;
      &lt;li&gt;Package Name（项目ID，可随便写）&lt;/li&gt;
      &lt;li&gt;Author/Maintainer Name
        &lt;ul&gt;
          &lt;li&gt;作者&lt;/li&gt;
          &lt;li&gt;直接回车就行，默认Mac上的用户名&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;[iphone/tweak] MobileSubstrate Bundle filter
        &lt;ul&gt;
          &lt;li&gt;需要修改的APP的Bundle identifier&lt;/li&gt;
          &lt;li&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Cycript&lt;/code&gt;查看APP的Bundle identifier&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;[iphone/tweak] List of applications to terminate upon installation
        &lt;ul&gt;
          &lt;li&gt;直接回车就行&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;makefile&quot;&gt;编辑Makefile&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在前面加入环境变量，写清楚通过哪个IP和端口访问手机
    &lt;ul&gt;
      &lt;li&gt;THEOS_DEVICE_IP&lt;/li&gt;
      &lt;li&gt;THEOS_DEVICE_PORT&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```
export THEOS_DEVICE_IP=127.0.0.1
export THEOS_DEVICE_PORT=10010&lt;/p&gt;

&lt;p&gt;include $(THEOS)/makefiles/common.mk&lt;/p&gt;

&lt;p&gt;TWEAK_NAME = tingtweak2
tingtweak2_FILES = Tweak.xm&lt;/p&gt;

&lt;p&gt;include $(THEOS_MAKE_PATH)/tweak.mk&lt;/p&gt;

&lt;p&gt;after-install::
	install.exec “killall -9 SpringBoard”
```&lt;/p&gt;

&lt;p&gt;如果不希望每个项目的Makefile都编写IP和端口环境变量，也可以添加到用户的配置文件中，编辑完毕后&lt;code class=&quot;highlighter-rouge&quot;&gt;$ source ~/.bash_profile&lt;/code&gt;(或者重启终端)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ vim ~/.bash_profile
export THEOS=~/theos
export PATH=$THEOS/bin:$PATH
export THEOS_DEVICE_IP=127.0.0.1
export THEOS_DEVICE_PORT=10010
$ source ~/.bash_profile
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;编写代码&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;打开&lt;code class=&quot;highlighter-rouge&quot;&gt;Tweak.xm&lt;/code&gt;文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```
%hook XMSoundPatchImageView&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(id)initWithFrame:(struct CGRect)arg1{
  return nil;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;%end&lt;/p&gt;

&lt;p&gt;%hook XMAdAnimationViewTwo&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(id)initWithFrame:(struct CGRect)arg1{
  return nil;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;%end
```&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;编译-打包-安装&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;编译&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
make
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;打包成&lt;code class=&quot;highlighter-rouge&quot;&gt;deb&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
make package
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
make install
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;可能遇到的问题&lt;/h2&gt;

&lt;h4 id=&quot;make-package&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make package&lt;/code&gt;的错误&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
 $ make package
  Can&#39;t locate IO/Compress/Lzma.pm in @INC (you may need to install the
  IO::Compress::Lzma module) (@INC contains: /Library/Perl/5.18/darwin-
  thread-multi-2level /Library/Perl/5.18 /Network/Library/Perl/5.18/darwin-
  thread-multi-2level /Network/Library/Perl/5.18 /Library/Perl/Updates/5.18.2
  /System/Library/Perl/5.18/darwin-thread-multi-2level
  /System/Library/Perl/5.18 /System/Library/Perl/Extras/5.18/darwin-thread-
  multi-2level /System/Library/Perl/Extras/5.18 .) at
  /Users/mj/theos/bin/dm.pl line 12.
  BEGIN failed--compilation aborted at /Users/mj/theos/bin/dm.pl line 12.
  make: *** [internal-package] Error 2
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是因为打包压缩方式有问题，改成&lt;code class=&quot;highlighter-rouge&quot;&gt;gzip&lt;/code&gt;压缩就行了
    &lt;ul&gt;
      &lt;li&gt;修改&lt;code class=&quot;highlighter-rouge&quot;&gt;dm.pl&lt;/code&gt;文件，用&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;号注释掉下面两句&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ vim $THEOS/vendor/dm.pl/dm.pl
#use IO::Compress::Lzma;
#use IO::Compress::Xz;
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;修改&lt;code class=&quot;highlighter-rouge&quot;&gt;deb.mk&lt;/code&gt;文件第6行的压缩方式为&lt;code class=&quot;highlighter-rouge&quot;&gt;gzip&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ vim $THEOS/makefiles/package/deb.mk
           _THEOS_PLATFORM_DPKG_DEB_COMPRESSION ?= gzip
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;make&quot;&gt;make的错误&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ make
  Error: You do not have an SDK in
  /Library/Developer/CommandLineTools/Platforms/iPhoneOS.platform/Developer/S
  DKs
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是因为多个Xcode导致路径（可能安装了多个xcode）,需要指定以下xcode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ sudo xcode-select --switch
/Applications/Xcode.app/Contents/Developer/
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;之前编译过，有会有以下提示&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ make
  &amp;gt; Making all for tweak xxx...
  make[2]: Nothing to be done for `internal-library-compile&#39;. 
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这是因为缓存导致的，但是不影响操作，如需出现原来的打印，可以&lt;code class=&quot;highlighter-rouge&quot;&gt;clean&lt;/code&gt;一下&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ make clean
$ make
&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 28 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://www.cenzhijun.top//2018/01/theos/</link>
        <guid isPermaLink="true">http://www.cenzhijun.top//2018/01/theos/</guid>
        
        <category>逆向</category>
        
        
      </item>
    
      <item>
        <title>（6）脱壳</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;加壳&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170517356893.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;什么是加壳？
    &lt;ul&gt;
      &lt;li&gt;利用特殊的算法，对可执行文件的编码进行改变（比如压缩、加密），以达到保护程序代码的目的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170517891591.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;脱壳&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;什么是脱壳？
    &lt;ul&gt;
      &lt;li&gt;摘掉壳程序，将未加密的可执行文件还原出来（有些人也称为“砸壳”）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;脱壳主要有2种方法：硬脱壳、动态脱壳&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170518676496.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ios&quot;&gt;iOS中的脱壳工具&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;iOS中有很多好用的脱壳工具
    &lt;ul&gt;
      &lt;li&gt;Clutch：https://github.com/KJCracks/Clutch&lt;/li&gt;
      &lt;li&gt;dumpdecrypted：https://github.com/stefanesser/dumpdecrypted/&lt;/li&gt;
      &lt;li&gt;AppCrackr、Crackulous（基本不用，常用前两种）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;如何验证可执行文件是否已经脱壳？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;将可执行的Mach-o文件拖入&lt;code class=&quot;highlighter-rouge&quot;&gt;Hopper Disassembler v4&lt;/code&gt;当中 查看&lt;code class=&quot;highlighter-rouge&quot;&gt;Load Commands -&amp;gt; LC_ENCRYPTION_INFO -&amp;gt; Crypt ID&lt;/code&gt;的值，0代表未加密&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170520564178.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过otool命令行也可以：&lt;code class=&quot;highlighter-rouge&quot;&gt;otool   -l   可执行文件路径   |   grep   crypt &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;clutch---&quot;&gt;Clutch - 配置&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;下载最新的Release版： https://github.com/KJCracks/Clutch/releases&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170521755298.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;建议去掉版本号，改名为Clutch&lt;/li&gt;
  &lt;li&gt;将Clutch文件拷贝到iPhone的/usr/bin目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170521587526.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果在iPhone上执行Clutch指令，权限不够，赋予“可执行的权限”
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170522024702.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;clutch--&quot;&gt;Clutch – 使用&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;列出已安装的APP：Clutch -i&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170522344555.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输入APP序号或者Bundle Id进行脱壳操作：&lt;code class=&quot;highlighter-rouge&quot;&gt;Clutch -d APP序号或BundleId&lt;/code&gt;
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170522669230.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170522849211.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;脱壳成功后会生成一个ipa文件
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170523045925.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dumdecrypted&quot;&gt;dumdecrypted&lt;/h2&gt;

&lt;p&gt;下载源代码，然后在源代码目录执行make指令进行编译，获得dylib动态库文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170523460875.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170523556274.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将dylib文件拷贝到iPhone上（如果是root用户，建议放&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/root&lt;/code&gt;目录）&lt;/li&gt;
  &lt;li&gt;终端进入dylib所在的目录&lt;/li&gt;
  &lt;li&gt;使用环境变量&lt;code class=&quot;highlighter-rouge&quot;&gt;DYLD_INSERT_LIBRARIES&lt;/code&gt;将dylib注入到需要脱壳的可执行文件（可执行文件路径可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ps -A&lt;/code&gt;查看获取）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170524361390.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.decrypted文件就是脱壳后的可执行文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170524639653.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dumdecrypted--&quot;&gt;dumdecrypted – 细节&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在使用过程中，可能会遇到以下错误
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170524940481.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;原因：对dylib所在的文件夹权限不够&lt;/li&gt;
  &lt;li&gt;解决方案：将dylib放在用户所在文件夹，比如
    &lt;ul&gt;
      &lt;li&gt;如果是root用户，请将dylib放在&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/root&lt;/code&gt;目录&lt;/li&gt;
      &lt;li&gt;如果是mobile用户，请将dylib放在&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/mobile&lt;/code&gt;目录&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 27 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://www.cenzhijun.top//2018/01/%E8%84%B1%E5%A3%B3/</link>
        <guid isPermaLink="true">http://www.cenzhijun.top//2018/01/%E8%84%B1%E5%A3%B3/</guid>
        
        <category>逆向</category>
        
        
      </item>
    
      <item>
        <title>（4）Reveal真机调试</title>
        <description>&lt;p&gt;Reveal是一款调试iOS程序UI界面的神器&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;官网：https://revealapp.com&lt;/li&gt;
  &lt;li&gt;下载：https://revealapp.com/download/&lt;/li&gt;
  &lt;li&gt;建议下载至少Reveal4版本，支持USB连接调试，速度快。低版本的只能WiFi连接调试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;调试环境配置&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;iPhone上安装Reveal Loader&lt;/li&gt;
  &lt;li&gt;安装完Reveal Loader后，打开【设置】，选择需要调试的APP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170495730063.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;找到Mac的Reveal中的&lt;code class=&quot;highlighter-rouge&quot;&gt;RevealServer&lt;/code&gt;文件，覆盖iPhone的&lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/RHRevealLoader/RevealServer&lt;/code&gt;文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170496337957.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重启SpringBoard或者重启手机，可以在iPhone上输入终端命令&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重启SpringBoard：killall SpringBoard&lt;/li&gt;
  &lt;li&gt;重启手机：reboot&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170496752227.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;有可能遇到的小问题&lt;/h2&gt;

&lt;p&gt;安装Reveal Loader的时候，遇到了一个小问题，安装完毕提示缺少依赖：
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170497719182.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;解决方法是：&lt;/h4&gt;
&lt;p&gt;删除掉bigboss源，重新安装，之后下载&lt;code class=&quot;highlighter-rouge&quot;&gt;Reveal2Loader&lt;/code&gt;就可以了&lt;/p&gt;

</description>
        <pubDate>Sat, 27 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://www.cenzhijun.top//2018/01/reveal/</link>
        <guid isPermaLink="true">http://www.cenzhijun.top//2018/01/reveal/</guid>
        
        <category>逆向</category>
        
        
      </item>
    
      <item>
        <title>（5）初识Mach-O</title>
        <description>&lt;h2 id=&quot;app1&quot;&gt;APP从开发到安装到手机的过程1&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170501088619.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MJRefreshExample.app中的MJRefreshExample文件是iOS中的可执行文件，文件格式是Mach-O&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;app2&quot;&gt;APP从开发到安装到手机的过程2&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170501525919.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;app&quot;&gt;逆向APP的思路&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;界面分析
    &lt;ul&gt;
      &lt;li&gt;Cycript、Reveal&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;代码分析
    &lt;ul&gt;
      &lt;li&gt;对Mach-O文件的静态分析&lt;/li&gt;
      &lt;li&gt;MachOView、class-dump、Hopper Disassembler、ida等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动态调试
    &lt;ul&gt;
      &lt;li&gt;对运行中的APP进行代码调试&lt;/li&gt;
      &lt;li&gt;debugserver、LLDB&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;代码编写
    &lt;ul&gt;
      &lt;li&gt;注入代码到APP中&lt;/li&gt;
      &lt;li&gt;必要时还可能需要重新签名、打包ipa&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;class-dump&quot;&gt;class-dump&lt;/h2&gt;

&lt;p&gt;顾名思义，它的作用就是把Mach-O文件的class信息给dump出来（把类信息给导出来），生成对应的.h头文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;官方地址：http://stevenygard.com/projects/class-dump/&lt;/li&gt;
  &lt;li&gt;下载完工具包后将class-dump文件复制到Mac的&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/bin&lt;/code&gt;目录，这样在终端就能识别&lt;code class=&quot;highlighter-rouge&quot;&gt;class-dump&lt;/code&gt;命令了&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;常用格式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class-dump  -H  Mach-O文件路径  -o  头文件存放目录&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;-H表示要生成头文件&lt;/li&gt;
      &lt;li&gt;-o用于制定头文件的存放目录&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;代码的编译过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170504403602.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在同一种架构平台下，每一条汇编指令都有与之对应的唯一的机器指令&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不同的OC代码，编译出来的汇编代码可能是一样的
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170504997663.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hopper-disassmbler&quot;&gt;Hopper Disassmbler&lt;/h2&gt;

&lt;p&gt;Hopper Disassmbler能够将Mach-O文件的机器语言代码反编译成汇编代码、OC伪代码或者Swift伪代码&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常用快捷键
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Shift + Option + X&lt;/code&gt;（找出哪里引用了这个方法）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dyld-shared-cache&quot;&gt;动态库共享缓存（dyld shared cache）&lt;/h2&gt;

&lt;p&gt;从iOS3.1开始，为了提高性能，绝大部分的系统动态库文件都打包存放到了一个缓存文件中（dyld shared cache）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;缓存文件路径：&lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/Caches/com.apple.dyld/dyld_shared_cache_armX&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170506785604.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;动态库的加载&lt;/h2&gt;

&lt;p&gt;在Mac\iOS中，是使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/dyld&lt;/code&gt;程序来加载动态库&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;dyld
    &lt;ul&gt;
      &lt;li&gt;dynamic link editor，动态链接编辑器&lt;/li&gt;
      &lt;li&gt;dynamic loader，动态加载器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;dyld源码
    &lt;ul&gt;
      &lt;li&gt;https://opensource.apple.com/tarballs/dyld/
## 从动态库共享缓存抽取动态库&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以使用dyld源码中的&lt;code class=&quot;highlighter-rouge&quot;&gt;launch-cache/dsc_extractor.cpp&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;#if 0&lt;/code&gt;前面的代码删除（包括&lt;code class=&quot;highlighter-rouge&quot;&gt;#if 0&lt;/code&gt;），把最后面的&lt;code class=&quot;highlighter-rouge&quot;&gt;#endif&lt;/code&gt;也删掉&lt;/li&gt;
  &lt;li&gt;编译dsc_extractor.cpp
    &lt;ul&gt;
      &lt;li&gt;clang++ -o dsc_extractor dsc_extractor.cpp&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用dsc_extractor
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;./dsc_extractor  动态库共享缓存文件的路径   用于存放抽取结果的文件夹&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mach-o&quot;&gt;Mach-O&lt;/h2&gt;

&lt;p&gt;Mach-O是Mach object的缩写，是Mac\iOS上用于存储程序、库的标准格式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;属于Mach-O格式的文件类型有&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170509565684.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以在xnu源码中，查看到Mach-O格式的详细定义（https://opensource.apple.com/tarballs/xnu/）
    &lt;ul&gt;
      &lt;li&gt;EXTERNAL_HEADERS/mach-o/fat.h&lt;/li&gt;
      &lt;li&gt;EXTERNAL_HEADERS/mach-o/loader.h&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mach-o-1&quot;&gt;常见的Mach-O文件类型&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;MH_OBJECT
    &lt;ul&gt;
      &lt;li&gt;目标文件（.o）&lt;/li&gt;
      &lt;li&gt;静态库文件(.a），静态库其实就是N个.o合并在一起&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MH_EXECUTE：可执行文件
    &lt;ul&gt;
      &lt;li&gt;.app/xx&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MH_DYLIB：动态库文件
    &lt;ul&gt;
      &lt;li&gt;.dylib&lt;/li&gt;
      &lt;li&gt;.framework/xx&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MH_DYLINKER：动态链接编辑器
    &lt;ul&gt;
      &lt;li&gt;/usr/lib/dyld&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MH_DSYM：存储着二进制文件符号信息的文件
    &lt;ul&gt;
      &lt;li&gt;.dSYM/Contents/Resources/DWARF/xx（常用于分析APP的崩溃信息）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170511417803.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;xcodetargetmach-o&quot;&gt;在Xcode中查看target的Mach-O类型&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170511627723.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mach-o-2&quot;&gt;Mach-O的基本结构&lt;/h2&gt;

&lt;p&gt;官方描述&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个Mach-O文件包含3个主要区域&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Header (文件类型、目标架构类型等
)&lt;/li&gt;
      &lt;li&gt;Load commands(描述文件在虚拟内存中的逻辑结构、布局
)&lt;/li&gt;
      &lt;li&gt;Raw segment data（在Load commands中定义的Segment的原始数据
）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-28-15170512878063.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mach-o-3&quot;&gt;窥探Mach-O的结构&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;命令行工具
    &lt;ul&gt;
      &lt;li&gt;file：查看Mach-O的文件类型
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;file  文件路径
&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;otool：查看Mach-O特定部分和段的内容&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;lipo：常用于多架构Mach-O文件的处理
    &lt;ul&gt;
      &lt;li&gt;查看架构信息：&lt;code class=&quot;highlighter-rouge&quot;&gt;lipo  -info  文件路径&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;导出某种特定架构：&lt;code class=&quot;highlighter-rouge&quot;&gt;lipo  文件路径  -thin  架构类型  -output  输出文件路径&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;合并多种架构：&lt;code class=&quot;highlighter-rouge&quot;&gt;lipo  文件路径1  文件路径2  -output  输出文件路径&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;GUI工具
    &lt;ul&gt;
      &lt;li&gt;MachOView（https://github.com/gdbinit/MachOView）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;universal-binary&quot;&gt;Universal Binary（通用二进制文件）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;通用二进制文件
    &lt;ul&gt;
      &lt;li&gt;同时适用于多种架构的二进制文件&lt;/li&gt;
      &lt;li&gt;包含了多种不同架构的独立的二进制文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;因为需要储存多种架构的代码，通用二进制文件通常比单一平台二进制的程序要大&lt;/li&gt;
  &lt;li&gt;由于两种架构有共同的一些资源，所以并不会达到单一版本的两倍之多&lt;/li&gt;
  &lt;li&gt;由于执行过程中，只调用一部分代码，运行起来也不需要额外的内存&lt;/li&gt;
  &lt;li&gt;因为文件比原来的要大，也被称为“胖二进制文件”（Fat Binary）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dyldmach-o&quot;&gt;dyld和Mach-O&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;dyld用于加载以下类型的Mach-O文件
    &lt;ul&gt;
      &lt;li&gt;MH_EXECUTE&lt;/li&gt;
      &lt;li&gt;MH_DYLIB&lt;/li&gt;
      &lt;li&gt;MH_BUNDLE&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;APP的可执行文件、动态库都是由dyld负责加载的&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 27 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://www.cenzhijun.top//2018/01/mach-o/</link>
        <guid isPermaLink="true">http://www.cenzhijun.top//2018/01/mach-o/</guid>
        
        <category>逆向</category>
        
        
      </item>
    
      <item>
        <title>（3）Cycript</title>
        <description>&lt;h2 id=&quot;cycript&quot;&gt;什么是Cycript&lt;/h2&gt;

&lt;p&gt;Cycript是Objective-C++、ES6（JavaScript）、Java等语法的混合物&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以用来探索、修改、调试正在运行的Mac\iOS APP&lt;/li&gt;
  &lt;li&gt;官网： http://www.cycript.org/&lt;/li&gt;
  &lt;li&gt;文档： http://www.cycript.org/manual/&lt;/li&gt;
  &lt;li&gt;通过Cydia安装Cycript，即可在iPhone上调试运行中的APP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-22-15166098213735.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cycript-1&quot;&gt;Cycript的开启和关闭&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;开启
    &lt;ul&gt;
      &lt;li&gt;cycript&lt;/li&gt;
      &lt;li&gt;cycript -p 进程ID&lt;/li&gt;
      &lt;li&gt;cycript -p 进程名称&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-22-15166099407954.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;取消输入：Ctrl + C&lt;/li&gt;
  &lt;li&gt;退出：Ctrl + D&lt;/li&gt;
  &lt;li&gt;清屏：Command + R&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ps&quot;&gt;ps命令&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;安装adv-cmds&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-22-15166100367048.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ps命令是process status的缩写，使用ps命令可以列出系统当前的进程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;列出所有的进程
    &lt;ul&gt;
      &lt;li&gt;ps –A&lt;/li&gt;
      &lt;li&gt;ps aux&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;搜索关键词
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;ps –A&lt;/td&gt;
              &lt;td&gt;grep 关键词&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;常用语法1&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;UIApp （[UIApplication sharedApplication]）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-22-15166101582794.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义变量
    &lt;ul&gt;
      &lt;li&gt;var 变量名 = 变量值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用内存地址获取对象
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#内存地址&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ObjectiveC.classes
    &lt;ul&gt;
      &lt;li&gt;已加载的所有OC类&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;查看对象的所有成员变量
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*对象&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-22-15166102765712.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;常用语法2&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;递归打印view的所有子控件（跟LLDB一样的函数）
    &lt;ul&gt;
      &lt;li&gt;view.recursiveDescription().toString()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;筛选出某种类型的对象
    &lt;ul&gt;
      &lt;li&gt;choose(UIViewController)&lt;/li&gt;
      &lt;li&gt;choose(UITableViewCell)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cycript---cy&quot;&gt;封装Cycript - .cy文件编写&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;我们可以将常用的Cycript代码封装在一个.cy文件中&lt;/li&gt;
  &lt;li&gt;exports参数名固定，用于向外提供接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-22-15166104113604.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cycript---cy-1&quot;&gt;封装Cycript - 存放和使用.cy文件&lt;/h2&gt;

&lt;p&gt;将.cy文件存放到/usr/lib/cycript0.9目录下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-22-15166104607678.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Cycript中引用.cy文件，并使用它提供的接口&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-22-15166104821399.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cycript-2&quot;&gt;Cycript库&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://github.com/CoderMJLee/mjcript&lt;/li&gt;
  &lt;li&gt;具体用法参考mjcript.cy文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;python&quot;&gt;利用python打印字符&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-22-15166105772382.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-22-15166105824565.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://www.cenzhijun.top//2018/01/Cycript/</link>
        <guid isPermaLink="true">http://www.cenzhijun.top//2018/01/Cycript/</guid>
        
        <category>逆向</category>
        
        
      </item>
    
      <item>
        <title>（2）逆向环境搭建</title>
        <description>&lt;h2 id=&quot;maciphone&quot;&gt;Mac远程登录到iPhone&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;我们经常在Mac的终端上，通过敲一些命令行来完成一些操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-Terminal.png&quot; alt=&quot;Termina&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;iOS和Mac OS X都是基于Darwin（苹果的一个基于Unix的开源系统内核），所以iOS中同样支持终端的命令行操作&lt;/li&gt;
  &lt;li&gt;在逆向工程中，我们经常会通过命令行来操纵iPhone&lt;/li&gt;
  &lt;li&gt;为了能够让Mac终端中的命令行能作用在iPhone上，我们得让Mac和iPhone建立连接&lt;/li&gt;
  &lt;li&gt;通过Mac远程登录到iPhone的方式建立连接
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-mac-iphone.jpg&quot; alt=&quot;mac-iphone&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sshopenssh&quot;&gt;SSH、OpenSSH&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SSH
    &lt;ul&gt;
      &lt;li&gt;Secure Shell的缩写，意为“安全外壳协议”，是一种可以为远程登录提供安全保障的协议&lt;/li&gt;
      &lt;li&gt;使用SSH，可以把所有传输的数据进行加密，“中间人”攻击方式就不可能实现，能防止DNS欺骗和IP欺骗
&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-ssh-sniffer.png&quot; alt=&quot;ssh-sniffe&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OpenSSH
    &lt;ul&gt;
      &lt;li&gt;是SSH协议的免费开源实现&lt;/li&gt;
      &lt;li&gt;可以通过OpenSSH的方式让Mac远程登录到iPhone&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;openssh&quot;&gt;使用OpenSSH远程登录&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;在iPhone上通过Cydia安装OpenSSH工具（软件源http://apt.saurik.com）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-OpenSSH.png&quot; alt=&quot;OpenSSH&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OpenSSH的具体使用步骤可以查看Description中的描述&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-OpenSSH-desc.png&quot; alt=&quot;OpenSSH-des&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初次使用步骤
    &lt;ul&gt;
      &lt;li&gt;SSH是通过TCP协议通信，所以要确保Mac和iPhone在同一局域网下，比如连接着同一个WiFi&lt;/li&gt;
      &lt;li&gt;在Mac的终端输入&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh root@服务器主机地址&lt;/code&gt;，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh root@10.1.1.168&lt;/code&gt;（这里的服务器是手机）&lt;/li&gt;
      &lt;li&gt;初始密码&lt;code class=&quot;highlighter-rouge&quot;&gt;alpine&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;登录成功后就可以使用终端命令行操作iPhone&lt;/li&gt;
      &lt;li&gt;退出登录命令是&lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-login_handle_step.png&quot; alt=&quot;login_handle_step&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rootmobile&quot;&gt;root和mobile&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;iOS下有2个常用账户：&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;mobile&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;：最高权限账户，$HOME是&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/root&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mobile&lt;/code&gt;：普通权限账户，只能操作一些普通文件，不能操作系统级别的文件，$HOME是&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/mobile&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;登录mobile用户：&lt;code class=&quot;highlighter-rouge&quot;&gt;root mobile@服务器主机地址&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;root和mobile用户的初始登录密码都是&lt;code class=&quot;highlighter-rouge&quot;&gt;alpine&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-modify_passwd.png&quot; alt=&quot;modify_passwd&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ssh&quot;&gt;SSH的安全验证方式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SSH提供了2种方式的安全验证
    &lt;ul&gt;
      &lt;li&gt;基于口令的安全验证
        &lt;ul&gt;
          &lt;li&gt;使用帐号和口令即可验证（口令就是密码）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;基于密钥的安全验证
        &lt;ul&gt;
          &lt;li&gt;免口令验证&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ssh---&quot;&gt;SSH - 基于密钥的安全验证&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-flow_chart.png&quot; alt=&quot;flow_chart&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;key-pairpublic-keyprivate-key&quot;&gt;在客户端生成一对相关联的密钥（Key Pair）：一个公钥（Public Key），一个私钥（Private Key）&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;怎么生成公钥和私钥&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
ssh-copy-id root@服务器主机地址
&lt;/code&gt;
&amp;gt; 一路敲回车键（Enter）即可
&amp;gt; 生成的公钥：&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/id_rsa.pub&lt;/code&gt;
&amp;gt; 生成的私钥：&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/id_rsa&lt;/code&gt;&lt;/p&gt;

&lt;h6 id=&quot;sshauthorizedkeys&quot;&gt;把客户端的公钥内容追加到服务器的授权文件（~/.ssh/authorized_keys）尾部&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;怎么追加&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
ssh-copy-id root@服务器主机地址
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要输入root用户的登录密码
&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-copy-id&lt;/code&gt;会将客户端&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/id_rsa.pub&lt;/code&gt;的内容自动追加到服务器的&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/authorized_keys&lt;/code&gt;尾部&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;整个过程使用RSA非对称加密算法（公钥进行加密、私钥进行解密）保证安全性&lt;/li&gt;
  &lt;li&gt;注意：由于是在~文件夹下操作，所以上述操作仅仅是解决了root用户的登录问题（不会影响mobile用户）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;公钥 » 授权文件&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;可以使用ssh-copy-id将客户端的公钥内容自动追加到服务器的授权文件尾部，也可以手动操作
    &lt;ul&gt;
      &lt;li&gt;复制客户端的公钥到服务器某路径
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scp ~/.ssh/id_rsa.pub root@服务器主机地址:~&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scp&lt;/code&gt;是secure copy的缩写，是基于SSH登录进行安全的远程文件拷贝命令，把一个文件copy到远程另外一台主机上&lt;/li&gt;
          &lt;li&gt;上面的命令行将客户端的&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/id_rsa.pub&lt;/code&gt;拷贝到了服务器的~地址&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SSH登录服务器
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh root@服务器主机地址&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;需要输入&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;用户的登录密码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在服务器创建.ssh文件夹
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir .ssh&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;追加公钥内容到授权文件尾部
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cat ~/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;删除公钥
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rm ~/id_rsa.pub&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sslopenssl&quot;&gt;SSL、OpenSSL&lt;/h2&gt;

&lt;p&gt;很多人会将SSH、OpenSSH、SSL、OpenSSL搞混&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SSL
    &lt;ul&gt;
      &lt;li&gt;Secure Sockets Layer的缩写，是为网络通信提供安全及数据完整性的一种安全协议，在传输层对网络连接进行加密&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OpenSSL
    &lt;ul&gt;
      &lt;li&gt;SSL的开源实现&lt;/li&gt;
      &lt;li&gt;绝大部分HTTPS请求等价于：HTTP + OpenSSL&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;opensshopenssl&quot;&gt;OpenSSH的加密就是通过OpenSSL完成的&lt;/h4&gt;

&lt;h2 id=&quot;usbssh&quot;&gt;通过USB进行SSH登录&lt;/h2&gt;

&lt;p&gt;默认情况下，由于SSH走的是TCP协议，Mac是通过网络连接的方式SSH登录到iPhone，要求iPhone连接WiFi。&lt;/p&gt;

&lt;p&gt;为了加快传输速度，也可以通过USB连接的方式进行SSH登录。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mac上有个服务程序usbmuxd（它会开机自动启动），可以实现USB进行SSH登陆&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/PrivateFrameworks/MobileDevice.framework/Resources/usbmuxd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;22端口&lt;/h2&gt;

&lt;p&gt;端口就是设备对外提供服务的窗口，每个端口都有个端口号（范围是0~65535，共2^16个）&lt;/p&gt;

&lt;p&gt;有些端口号是保留的，已经规定了用途，比如:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;21端口提供FTP服务&lt;/li&gt;
  &lt;li&gt;80端口提供HTTP服务&lt;/li&gt;
  &lt;li&gt;22端口提供SSH服务&lt;/li&gt;
  &lt;li&gt;更多保留端口号： https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7/10883658#4_3&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;iphone22sshtcp&quot;&gt;iPhone默认是使用22端口进行SSH通信，采用的是TCP协议&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-wifi_ssh_login.png&quot; alt=&quot;wifi_ssh_login&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;usbmuxd1&quot;&gt;usbmuxd的使用1&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;下载usbmuxd工具包（下载v1.0.8版本，主要用到里面的一个python脚本：tcprelay.py）&lt;/li&gt;
  &lt;li&gt;https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz&lt;/li&gt;
  &lt;li&gt;将iPhone的22端口（SSH端口）映射到Mac本地的10010端口&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~/Downloads/usbmuxd-1.0.8/python-client&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python tcprelay.py 22:10010&lt;/code&gt;
#### 注意：要想保持端口转换状态，不能终止此命令行（如果要执行其他终端命令行，请新开一个终端界面）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;不一定非要10010端口，只要不是保留端口就行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;usbmuxd2&quot;&gt;usbmuxd的使用2&lt;/h2&gt;
&lt;p&gt;端口映射完毕后，以后如果想跟iPhone的22端口通信，直接跟Mac本地的10010端口通信就可以了&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新开一个终端界面，SSH登录到Mac本地的10010端口（以下方式2选1）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh root@localhost -p 10010&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;ssh root@127.0.0.1 -p 10010&lt;/li&gt;
  &lt;li&gt;localhost是一个域名，指向的IP地址是127.0.0.1，本机虚拟网卡的IP地址&lt;/li&gt;
  &lt;li&gt;usbmuxd会将Mac本地10010端口的TCP协议数据，通过USB连接转发到iPhone的22端口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-usb_ssh_login.png&quot; alt=&quot;usb_ssh_login&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ios&quot;&gt;iOS终端的中文乱码问题&lt;/h2&gt;

&lt;p&gt;默认情况下，iOS终端不支持中文输入和显示&lt;/p&gt;

&lt;p&gt;解决方案：新建一个~/.inputrc文件，文件内容是：
* &lt;code class=&quot;highlighter-rouge&quot;&gt;set convert-meta off &lt;/code&gt;(不将中文字符转化为转义序列)
* &lt;code class=&quot;highlighter-rouge&quot;&gt;set output-meta on&lt;/code&gt;(允许向终端输出中文)
* &lt;code class=&quot;highlighter-rouge&quot;&gt;set meta-flag on &lt;/code&gt;（允许向终端输入中文）
* &lt;code class=&quot;highlighter-rouge&quot;&gt;set input-meta on&lt;/code&gt;（允许向终端输入中文）&lt;/p&gt;

&lt;h4 id=&quot;cydiavimhttpaptsaurikcom&quot;&gt;如果是想在终端编辑文件内容，可以通过Cydia安装一个vim（软件源http://apt.saurik.com）&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-vim_improved.png&quot; alt=&quot;vim_improved&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 21 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://www.cenzhijun.top//2018/01/%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
        <guid isPermaLink="true">http://www.cenzhijun.top//2018/01/%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
        
        <category>逆向</category>
        
        
      </item>
    
      <item>
        <title>（1）越狱环境搭建</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-jailbreak.png&quot; alt=&quot;jailbreak&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ios-jailbreakios&quot;&gt;什么是iOS Jailbreak（iOS越狱）&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
利用iOS系统漏洞，获取iOS系统的最高权限（Root），解开各种限制（合法行为）
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;jailbreak&quot;&gt;Jailbreak优缺点：&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;自由安装各种实用的插件、主题、APP&lt;/li&gt;
      &lt;li&gt;修改系统APP的一些默认行为&lt;/li&gt;
      &lt;li&gt;自由安装非AppSore来源的APP&lt;/li&gt;
      &lt;li&gt;灵活管理文件系统，让iPhone可以像U盘那样灵活&lt;/li&gt;
      &lt;li&gt;给开发者提供了逆向工程的环境&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;不予保修&lt;/li&gt;
      &lt;li&gt;费电，越狱后的iOS系统会常驻一些进程，耗电速度约提升10%~20%&lt;/li&gt;
      &lt;li&gt;不再受iOS系统默认的安全保护，容易被恶意软件攻击，个人隐私有被窃取的风险&lt;/li&gt;
      &lt;li&gt;如果安装了不稳定的插件，容易让系统变得不稳定、变慢，甚至出现“白苹果”等问题&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;完美越狱和不完美越狱&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;完美越狱
    &lt;ul&gt;
      &lt;li&gt;越狱后的iPhone可以正常关机和重启&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;不完美越狱
    &lt;ul&gt;
      &lt;li&gt;iPhone一旦关机后再开机时，屏幕就会一直停留在启动画面，也就是“白苹果”状态&lt;/li&gt;
      &lt;li&gt;或者能正常开机，但已经安装的破解软件都无法正常使用，需要将设备与PC连接后，使用软件进行引导才能使用&lt;/li&gt;
      &lt;li&gt;一般说来，在苹果发布新的iOS固件后，针对该固件的不完美越狱会先发布，随后完美越狱才可能发布&lt;/li&gt;
      &lt;li&gt;一般较新的系统版本，均为不完美越狱&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;## 越狱方法推荐&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;PP助手：http://jailbreak.25pp.com/&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;## 判断是否越狱成功&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;桌面是否有Cydia
  &lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-cydia.png&quot; alt=&quot;cydia&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cydia&quot;&gt;Cydia&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;越狱后的App Store
    &lt;ul&gt;
      &lt;li&gt;可以在Cydia中安装各种第三方的软件（插件、补丁、APP）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作者
    &lt;ul&gt;
      &lt;li&gt;Jay Freeman (saurik)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-saurik.png&quot; alt=&quot;saurik&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;常用软件源&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;http://apt.saurik.com&lt;/li&gt;
  &lt;li&gt;http://apt.25pp.com&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iphone&quot;&gt;iPhone必备&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Cydia&lt;/li&gt;
  &lt;li&gt;Apple File Conduit “2”（可以访问整个iOS设备的文件系统）&lt;/li&gt;
  &lt;li&gt;AppSync Unified（可以绕过系统验证，随意安装、运行破解的ipa安装包）&lt;/li&gt;
  &lt;li&gt;iFile（可以在iPhone上自由访问iOS文件系统）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mac&quot;&gt;Mac必备&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;iFunbox
    &lt;ul&gt;
      &lt;li&gt;管理文件系统&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PP助手
    &lt;ul&gt;
      &lt;li&gt;自由安装海量APP&lt;/li&gt;
      &lt;li&gt;卸载APP&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://otogtitz7.bkt.clouddn.com/2018-01-21-ifunbox-pp.png&quot; alt=&quot;ifunbox-pp&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;最简单的方法判断设备是否越狱&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
- (BOOL)isJailbreak{
    return [[NSFileManager defaultManager] fileExistsAtPath:@&quot;/Applications/Cydia.app&quot;];
}
&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 21 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://www.cenzhijun.top//2018/01/%E6%90%AD%E5%BB%BA%E8%B6%8A%E7%8B%B1%E7%8E%AF%E5%A2%83/</link>
        <guid isPermaLink="true">http://www.cenzhijun.top//2018/01/%E6%90%AD%E5%BB%BA%E8%B6%8A%E7%8B%B1%E7%8E%AF%E5%A2%83/</guid>
        
        <category>逆向</category>
        
        
      </item>
    
  </channel>
</rss>
